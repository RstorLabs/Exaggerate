defmodule Exaggerate.Router do

  alias Exaggerate.AST

  defstruct vars: ["conn"],
            guards: [],
            elses: []

  @type t :: %__MODULE__{
    vars:   [String.t],
    guards: [AST.leftarrow],
    elses:  [AST.rightarrow]
  }

  @type spec_data :: float | integer | String.t
                   | [spec_data] | %{optional(String.t) => spec_data}
  @typedoc """
    maps containing swagger spec information.
  """
  @type spec_map :: %{optional(String.t) => spec_data}

  @spec module(String.t, Path.t, spec_map) :: AST.ast
  def module(module_name, _filename, _swaggertree) do

    module = (module_name <> "_web")
    |> Macro.camelize
    |> Module.concat(Router)

    filename = "test.json"

    code = [quote do
    end]

    quote do
      defmodule unquote(module) do

        @comment
        @comment "--WARNING--"
        @comment
        @comment "all code below is autogenerated.  Alterations to this code risk "
        @comment "introducing deviations to the supplied OpenAPI specification."
        @comment "Please consider modifying #{unquote(filename)} instead of this"
        @comment "file, followed by"
        @comment
        @comment "    mix swagger.update #{unquote(filename)}"
        @comment

        unquote_splicing(code)
      end
    end
  end

  # OpenAPI 3.0 supports the following verbs for operations:
  # https://swagger.io/docs/specification/paths-and-operations/#operations

  @type http_verb :: :get | :post | :put | :patch |
                     :delete | :head | :options | :trace

  @spec route({String.t, http_verb}, spec_map) :: AST.ast
  def route({path!, verb}, spec = %{"operationId" => op}) do
    do_block = %__MODULE__{}
    |> build_params(spec)
    |> validations(spec)
    |> finalize(spec)
    |> assemble(spec)

    path! = AST.swagger_to_sinatra(path!)

    {verb, [], [path!, [do: do_block]]}
  end

  defp build_summary(list, nil), do: list
  defp build_summary(list, summary) do
    list ++ [quote do
      @comment unquote(summary)
    end]
  end

  @spec build_params(t, spec_map)::t
  defp build_params(parser, %{"requestBody" => rq_map}) do
    if rq_map["content"] do
      mimetype_list = Map.keys(rq_map["content"])

      parser
      |> push_var("content")
      |> push_guard(quote do
        {:ok, content_type} <- Process.requestbody_content(conn, unquote(mimetype_list))
      end)
    else
      parser
    end
  end
  defp build_params(parser, %{"parameters" => params}) do
    Enum.reduce(params, parser, &build_param/2)
  end
  defp build_params(parser, _), do: parser

  @jsonschema_types ["integer", "string", "object", "array", "number", "boolean", "null"]

  @spec fetcher(String.t) :: atom
  # generates a fetcher symbol that lives in the Exonerate.Tools module.
  defp fetcher(location), do: String.to_atom("get_" <> location)

  @spec names_for(String.t, String.t) :: {String.t, String.t}
  # canonicalizes names to an elixir reasonable symbols.
  defp names_for(name, "header") do
    {name
    |> String.replace("-", "_")
    |> String.downcase,
    name}
  end
  defp names_for(name, _) do
    snake = Macro.underscore(name)
    {snake, snake}
  end

  defp build_param(%{"in" => location,
                     "required" => true,
                     "name" => name,
                     "schema" => %{"type" => type}}, parser)
                     when type in @jsonschema_types do
    fetch_fn = fetcher(location)
    {var_name, fetch_name} = names_for(name, location)
    name_ast = AST.var_ast(var_name)
    type_atom = String.to_atom(type)
    parser
    |> push_var(var_name)
    |> push_guard(quote do
      {:ok, unquote(name_ast)}
        <- Tools.unquote(fetch_fn)(conn, unquote(fetch_name), unquote(type_atom))
    end)
  end
  defp build_param(%{"in" => location,
                     "required" => true,
                     "name" => name}, parser) do
    fetch_fn = fetcher(location)
    {var_name, fetch_name} = names_for(name, location)
    name_ast = AST.var_ast(var_name)
    parser
    |> push_var(var_name)
    |> push_guard(quote do
      {:ok, unquote(name_ast)} <- Tools.unquote(fetch_fn)(conn, unquote(fetch_name))
    end)
  end

  @spec validations(t, spec_map) :: t
  defp validations(parser, %{"operationId" => id,
                             "requestBody" => %{"content" => _}}) do
    validator = [id, "content"]
    |> Enum.join("_")
    |> String.to_atom

    %__MODULE__{parser | guards: parser.guards ++ [quote do
      :ok <- Validation.unquote(validator)(conn.body_params, content_type)
    end]}
  end
  defp validations(parser, _), do: parser

  @spec finalize(t, spec_map) :: t
  defp finalize(parser, spec = %{"operationId" => id}) do
    call = AST.generate_call(id, parser.vars)
    spec
    |> success_code
    |> case do
      :multi ->
        push_guard(parser, quote do
          {:ok, code, response} <- unquote(call)
        end)
      _ ->
        push_guard(parser, quote do
          {:ok, response} <- unquote(call)
        end)
    end
    |> push_else(quote do
      {:error, ecode, response} ->
        send_formatted(conn, ecode, response)
    end)
  end

  @spec push_var(t, String.t) :: t
  defp push_var(parser, str) do
    %__MODULE__{parser | vars: parser.vars ++ [str]}
  end

  @spec push_guard(t, AST.leftarrow) :: t
  defp push_guard(parser, ast) do
    %__MODULE__{parser | guards: parser.guards ++ [ast]}
  end

  @spec push_else(t, AST.rightarrow) :: t
  defp push_else(parser, ast) do
    %__MODULE__{parser | elses: parser.elses ++ [ast]}
  end

  @spec assemble(t, spec_map) :: AST.ast
  defp assemble(parser, spec) do

    code = spec
    |> success_code
    |> case do
      :multi -> {:code, [], Elixir}
      any -> any
    end

    with_ast = AST.generate_with(
      parser.guards,
      quote do send_formatted(conn, unquote(code), response) end,
      parser.elses
    )

    if spec["summary"] do
      quote do
        @comment unquote(spec["summary"])
        unquote(with_ast)
      end
    else
      with_ast
    end
  end

  @spec success_code(spec_map) :: :multi | integer
  def success_code(%{"responses" => rmap}) do
    cond do
      Map.has_key?(rmap, "1XX") -> :multi
      Map.has_key?(rmap, "2XX") -> :multi
      true ->
        list = rmap
        |> Map.keys
        |> Enum.map(&String.to_integer/1)
        |> Enum.filter(&(&1 < 300))
        successes = Enum.count(list)

        cond do
          successes == 0 -> 200
          successes == 1 -> Enum.at(list, 0)
          true -> :multi
        end
    end
  end
  # http code 200 is a default response code.
  def success_code(_spec), do: 200

end

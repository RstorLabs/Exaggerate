defmodule Exaggerate.Endpoint do

  defstruct params: [],
            status: false,
            type: false

  @type t::%__MODULE__{
    params: [atom],
    status: boolean,
    type: boolean
  }

  alias Exaggerate.AST

  @type endpointmap :: %{required(atom) => list(atom)}

  @doc """
  generates a skeleton endpoint module from an module name (string) and an
  endpoint map, which is a map structure representing atoms matched with a
  list of parameters to be passed into the map.

  Typically, the module name will derive from the basename of the json file
  from which the swagger template comes.  In general, this function will be
  called by `mix swagger` but not `mix swagger update`, which will parse out
  the existing functions first.
  """
  @spec module(String.t, endpointmap) :: AST.block
  def module(module_name, endpoints) do
    code = Enum.map(endpoints, &block/1)

    module = (module_name <> "_web")
    |> Macro.camelize
    |> Module.concat(Endpoint)

    quote do
      @comment ""
      @comment "NB. this file is autogenerated, altering the structure or arrangement"
      @comment "of the modules in this file can cause problems."
      @comment ""

      defmodule unquote(module) do
        unquote_splicing(code)
      end
    end
  end

  @doc """
  generates a skeleton endpoint block from an endpoint name (atom) and a
  list of matched variables.

  This block is intended to be filled out by the user.  @comment values
  are going to be swapped out, later in AST processing, for # comments.
  """
  @spec block({atom, t}) :: Macro.t
  def block({ep, v}), do: block(ep, v)

  @spec block(atom, t) :: Macro.t
  def block(endpoint, %__MODULE__{params: vars}) do
    raise_str = "error: #{endpoint} not implemented"
    mvars = Enum.map(vars, fn var -> {var, [], Elixir} end)
    quote do
      def unquote(endpoint)(conn, unquote_splicing(mvars)) do
        @comment "autogen function."
        @comment "insert your code here, then delete"
        @comment "the next exception:"

        raise unquote(raise_str)
      end
    end
  end

  @doc """
  analyzes an existing module document and retrieves a list of implemented
  endpoints.
  """
  @spec list_endpoints(binary) :: [atom]
  def list_endpoints(modulecode) when is_binary(modulecode) do
    modulecode
    |> Code.format_string!
    |> list_endpoints_io
  end

  @spec list_endpoints_io(iodata) :: [atom]
  def list_endpoints_io(["def", " ", endpoint | rest]) do
    [String.to_atom(endpoint) | list_endpoints_io(rest)]
  end
  def list_endpoints_io([]), do: []
  def list_endpoints_io([_ | rest]), do: list_endpoints_io(rest)

  @doc """
  pulls an existing file which contains an endpoint module and retrieves a
  list of implemented endpoints.
  """
  @spec list_file_endpoints(Path.t) :: [atom]
  def list_file_endpoints(filepath) do
    filepath
    |> Path.expand
    |> File.read!
    |> list_endpoints
  end

  defp insert_routes(content, new_routes) do
    lines = String.split(content, "\n")

    last_end_idx = lines
    |> Enum.with_index
    |> Enum.filter(fn {str, _} -> String.contains?(str, "end") end)
    |> Enum.map(fn {_, idx} -> idx end)
    |> Enum.max

    lines
    |> Enum.slice(0..(last_end_idx - 1))
    |> Enum.concat(new_routes)
    |> Enum.concat(["end\n"])
    |> Enum.join("\n")
    |> Code.format_string!
  end

  @spec update(Path.t, map) :: :ok | {:error, any}
  def update(filepath, routespec) do
    existing_routes = list_file_endpoints(filepath)

    new_routes = routespec
    |> Enum.reject(fn {k, _} -> k in existing_routes end)
    |> Enum.map(&block/1)
    |> Enum.map(&AST.to_string/1)

    updated_content = filepath
    |> File.read!
    |> insert_routes(new_routes)
    |> Enum.concat(["\n"])

    File.write!(filepath, updated_content)
  end
end
